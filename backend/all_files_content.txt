
### ./cmd/main.go ###

package main

import (
	"net/http"
	"surveillance/internal/config/cron"
	"surveillance/internal/config/database"
	"surveillance/internal/config/env"
	"surveillance/internal/routes"
	"surveillance/internal/utils"

	"github.com/labstack/echo/v4"
	"github.com/labstack/echo/v4/middleware"
)

func main() {
	env.LoadEnv()

	db := database.InitDB()
	scheduler, cronJobID := cron.StartScheduler(db)
	e := echo.New()

	e.Use(middleware.CORSWithConfig(middleware.CORSConfig{
		AllowOrigins: []string{"http://localhost:5173"},
		AllowMethods: []string{http.MethodGet, http.MethodPut, http.MethodPost, http.MethodDelete, http.MethodPatch},
	}))

	e.Use(func(next echo.HandlerFunc) echo.HandlerFunc {
		return func(c echo.Context) error {
			c.Set("db", db)
			c.Set("scheduler", scheduler)
			c.Set("cronJobID", &cronJobID)
			return next(c)
		}
	})
	e.GET("/favicon.ico", func(c echo.Context) error {
		return c.NoContent(http.StatusNoContent)
	})
	routes.RegisterRoutes(e, db, scheduler, &cronJobID)
	e.Static("/", "./frontend")

	utils.Logger.Fatal(e.Start(":8080"))
}

### ./go.mod ###

module surveillance

go 1.23.5

require (
	github.com/golang-jwt/jwt/v4 v4.5.1
	github.com/labstack/echo-jwt/v4 v4.3.0
	github.com/labstack/echo/v4 v4.13.3
	github.com/robfig/cron/v3 v3.0.1
	github.com/sirupsen/logrus v1.9.3
	golang.org/x/crypto v0.31.0
	gorm.io/driver/sqlite v1.5.7
	gorm.io/gorm v1.25.12
)

require (
	github.com/golang-jwt/jwt/v5 v5.2.1 // indirect
	github.com/jinzhu/inflection v1.0.0 // indirect
	github.com/jinzhu/now v1.1.5 // indirect
	github.com/joho/godotenv v1.5.1 // indirect
	github.com/labstack/gommon v0.4.2 // indirect
	github.com/mattn/go-colorable v0.1.13 // indirect
	github.com/mattn/go-isatty v0.0.20 // indirect
	github.com/mattn/go-sqlite3 v1.14.22 // indirect
	github.com/valyala/bytebufferpool v1.0.0 // indirect
	github.com/valyala/fasttemplate v1.2.2 // indirect
	golang.org/x/net v0.33.0 // indirect
	golang.org/x/sys v0.29.0 // indirect
	golang.org/x/text v0.21.0 // indirect
	golang.org/x/time v0.8.0 // indirect
)

### ./internal/config/cron/cron.go ###

package cron

import (
	"os"
	"surveillance/internal/models"
	"surveillance/internal/services"
	"surveillance/internal/utils"
	"time"

	"github.com/robfig/cron/v3"
	"gorm.io/gorm"
)

func StartScheduler(db *gorm.DB) (*cron.Cron, cron.EntryID) {

	timezone := os.Getenv("TIMEZONE")
	loc, err := time.LoadLocation(timezone)
	if err != nil {
		utils.Logger.Fatalf("Invalid TIMEZONE: %v", err)
	}

	scheduler := cron.New(cron.WithLocation(loc))

	var settings struct {
		CronSchedule string `gorm:"column:cron_schedule"`
	}
	if err := db.Table("settings").First(&settings).Error; err != nil {
		utils.Logger.Fatalf("Failed to fetch settings for cron: %v", err)
	}

	jobID, err := scheduler.AddFunc(settings.CronSchedule, func() {
		var reposCount int64
		if err := db.Model(&models.Repository{}).Count(&reposCount).Error; err != nil {
			utils.Logger.Errorf("Failed to fetch repositories count: %v", err)
			return
		}

		githubToken := utils.GetGitHubToken(db)
		if err := services.MonitorRepositories(db, githubToken, "Scheduled", false); err != nil {
			utils.Logger.Errorf("Repository scan failed: %v", err)
		}
	})
	if err != nil {
		utils.Logger.Fatalf("Failed to schedule cron job: %v", err)
	}

	utils.Logger.Infof("Cron job scheduled with ID: %d and schedule: %s", jobID, settings.CronSchedule)
	utils.Logger.Infof("Cron job timezone: %s", timezone)
	scheduler.Start()
	return scheduler, jobID
}

### ./internal/config/database/database.go ###

package database

import (
	"surveillance/internal/models"
	"surveillance/internal/utils"

	"gorm.io/driver/sqlite"
	"gorm.io/gorm"
	"gorm.io/gorm/logger"
)

func InitDB() *gorm.DB {
	dbPath := "./db/sqlite.db"
	db, err := gorm.Open(sqlite.Open(dbPath), &gorm.Config{
		Logger: logger.Default.LogMode(logger.Error),
	})
	if err != nil {
		utils.Logger.Fatal("Failed to connect to the database: ", err)
	}
	db.AutoMigrate(
		&models.Settings{},
		&models.Repository{},
		&models.NotificationSettings{},
		&models.User{},
	)
	ensureDefaultSettings(db)
	ensureDefaultNotificationSettings(db)
	return db
}

func ensureDefaultSettings(db *gorm.DB) {
	var count int64
	db.Model(&models.Settings{}).Count(&count)
	if count == 0 {
		db.Create(&models.Settings{
			Theme:        "tokyoNight",
			CronSchedule: "0 */12 * * *",
			GitHubAPIKey: "",
			LastScan:     "No scan performed yet",
		})
	}
}

func ensureDefaultNotificationSettings(db *gorm.DB) {
	var count int64
	db.Model(&models.NotificationSettings{}).Count(&count)
	if count == 0 {
		db.Create(&models.NotificationSettings{
			WebhookURL:    "",
			DiscordName:   "Surveillance Bot",
			DiscordAvatar: "",
			PingType:      "None",
		})
	}
}

### ./internal/config/env/env.go ###

package env

import (
	"fmt"
	"os"
	"time"

	"surveillance/internal/utils"

	"github.com/joho/godotenv" // import godotenv
)

func LoadEnv() {
	// Attempt to load from .env file (if present)
	if err := godotenv.Load(); err != nil {
		utils.Logger.Info("No .env file found. Using environment variables.")
	}

	// Get JWT_SECRET from environment (either from .env or docker-compose)
	jwtSecret := os.Getenv("JWT_SECRET")
	if jwtSecret == "" {
		fmt.Println("JWT_SECRET environment variable is required.")
		os.Exit(1)
	}

	// Generate a random salt (you may wish to persist this in production)
	salt, err := utils.GenerateRandomSalt(16)
	if err != nil {
		utils.Logger.Fatalf("Failed to generate random salt: %v", err)
		os.Exit(1)
	}

	// Read TIMEZONE from env or default to UTC
	timezone := os.Getenv("TIMEZONE")
	if timezone == "" {
		timezone = "UTC"
		utils.Logger.Info("TIMEZONE environment variable not set. Defaulting to UTC.")
	}
	loc, err := time.LoadLocation(timezone)
	if err != nil {
		utils.Logger.Fatalf("Invalid TIMEZONE environment variable (%s): %v", timezone, err)
		os.Exit(1)
	}
	time.Local = loc

	// Set the encryption parameters (using the JWT secret and salt)
	utils.SetEncryptionParameters(jwtSecret, salt)
}

### ./internal/services/discord_notification.go ###

package services

import (
	"bytes"
	"encoding/json"
	"fmt"
	"net/http"
	"surveillance/internal/models"
	"surveillance/internal/utils"
	"time"

	"gorm.io/gorm"
)

func SendDiscordNotification(db *gorm.DB, updateDetails string, scanType string) error {
	var settings models.NotificationSettings
	if err := db.First(&settings).Error; err != nil {
		utils.Logger.Errorf("Failed to retrieve notification settings: %v", err)
		return err
	}
	if settings.WebhookURL == "" {
		utils.Logger.Info("No Discord webhook URL is set; skipping notification.")
		return nil
	}

	type EmbedAuthor struct {
		Name    string `json:"name"`
		IconURL string `json:"icon_url,omitempty"`
	}

	type EmbedFooter struct {
		Text string `json:"text"`
	}

	type Embed struct {
		Title       string      `json:"title"`
		Color       int         `json:"color"`
		Description string      `json:"description"`
		Footer      EmbedFooter `json:"footer"`
		Author      EmbedAuthor `json:"author"`
	}

	type Payload struct {
		Username  string  `json:"username"`
		AvatarURL string  `json:"avatar_url,omitempty"`
		Content   string  `json:"content"`
		Embeds    []Embed `json:"embeds"`
	}

	ping := ""
	switch settings.PingType {
	case "@everyone":
		ping = "@everyone "
	case "@here":
		ping = "@here "
	}

	scanTypeString := "Scheduled Scan"
	if scanType == "Manual" {
		scanTypeString = "Manual Scan"
	} else if scanType == "Test" {
		scanTypeString = "Test Scan"
	}

	currentTime := time.Now().Format("Today at 3:04 PM")

	discordName := settings.DiscordName
	if discordName == "" {
		discordName = "Surveillance Bot"
	}

	embed := Embed{
		Title:       "Repository Updates Available",
		Color:       3447003,
		Description: updateDetails,
		Footer: EmbedFooter{
			Text: fmt.Sprintf("%s ‚Ä¢ %s", scanTypeString, currentTime),
		},
		Author: EmbedAuthor{
			Name:    "Surveillance",
			IconURL: settings.DiscordAvatar,
		},
	}

	payload := Payload{
		Username:  discordName,
		AvatarURL: settings.DiscordAvatar,
		Content:   ping,
		Embeds:    []Embed{embed},
	}

	jsonPayload, err := json.Marshal(payload)
	if err != nil {
		utils.Logger.Errorf("Failed to marshal Discord payload: %v", err)
		return err
	}

	req, err := http.NewRequest("POST", settings.WebhookURL, bytes.NewBuffer(jsonPayload))
	if err != nil {
		utils.Logger.Errorf("Failed to create Discord notification request: %v", err)
		return err
	}
	req.Header.Set("Content-Type", "application/json")

	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		utils.Logger.Errorf("Failed to send Discord notification: %v", err)
		return err
	}
	defer resp.Body.Close()

	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		utils.Logger.Errorf("Discord notification failed with status: %d", resp.StatusCode)
		return err
	}

	utils.Logger.Info("Discord notification sent successfully.")
	return nil
}

func SendTestDiscordNotification(db *gorm.DB) error {
	var settings models.NotificationSettings
	if err := db.First(&settings).Error; err != nil {
		utils.Logger.Errorf("Failed to retrieve notification settings: %v", err)
		return err
	}
	if settings.WebhookURL == "" {
		utils.Logger.Info("No Discord webhook URL is set; skipping notification.")
		return nil
	}

	type EmbedAuthor struct {
		Name    string `json:"name"`
		IconURL string `json:"icon_url,omitempty"`
	}

	type EmbedFooter struct {
		Text string `json:"text"`
	}

	type Embed struct {
		Title       string      `json:"title"`
		Color       int         `json:"color"`
		Description string      `json:"description"`
		Footer      EmbedFooter `json:"footer"`
		Author      EmbedAuthor `json:"author"`
	}

	type Payload struct {
		Username  string  `json:"username"`
		AvatarURL string  `json:"avatar_url,omitempty"`
		Content   string  `json:"content"`
		Embeds    []Embed `json:"embeds"`
	}

	exampleUpdates := "- [facebook/react](https://github.com/facebook/react): 2.5.1 ‚Üí v19.0.0\n"
	scanTypeString := "Test Scan"

	currentTime := time.Now().Format("Today at 3:04 PM")

	discordName := settings.DiscordName
	if discordName == "" {
		discordName = "Surveillance Bot"
	}

	ping := ""
	switch settings.PingType {
	case "@everyone":
		ping = "@everyone "
	case "@here":
		ping = "@here "
	}

	embed := Embed{
		Title:       "Repository Updates Available",
		Color:       3447003,
		Description: exampleUpdates,
		Footer: EmbedFooter{
			Text: fmt.Sprintf("%s ‚Ä¢ %s", scanTypeString, currentTime),
		},
		Author: EmbedAuthor{
			Name:    "Surveillance",
			IconURL: settings.DiscordAvatar,
		},
	}

	payload := Payload{
		Username:  discordName,
		AvatarURL: settings.DiscordAvatar,
		Content:   ping,
		Embeds:    []Embed{embed},
	}
	jsonPayload, err := json.Marshal(payload)
	if err != nil {
		utils.Logger.Errorf("Failed to marshal Discord payload: %v", err)
		return err
	}
	req, err := http.NewRequest("POST", settings.WebhookURL, bytes.NewBuffer(jsonPayload))
	if err != nil {
		utils.Logger.Errorf("Failed to create Discord notification request: %v", err)
		return err
	}

	req.Header.Set("Content-Type", "application/json")

	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		utils.Logger.Errorf("Failed to send Discord notification: %v", err)
		return err
	}
	defer resp.Body.Close()

	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		utils.Logger.Errorf("Discord notification failed with status: %d", resp.StatusCode)
		return err
	}

	utils.Logger.Info("Test Discord notification sent successfully.")
	return nil
}

### ./internal/services/scan_schedule.go ###

package services

import (
	"time"

	"github.com/robfig/cron/v3"
	"gorm.io/gorm"
)

func CalculateNextScan(cronExpression string) (string, error) {
	schedule, err := cron.ParseStandard(cronExpression)
	if err != nil {
		return "Invalid cron expression", err
	}
	nextScan := schedule.Next(time.Now())
	return formatNextScan(nextScan), nil
}

func GetLastAndNextScanTimes(db *gorm.DB) (lastScan, nextScan string) {
	var settings struct {
		LastScan     string
		CronSchedule string
	}
	db.Table("settings").Select("last_scan, cron_schedule").First(&settings)
	if settings.LastScan == "" {
		lastScan = "No scan performed yet"
	} else {
		lastScan = formatLastScan(settings.LastScan)
	}
	nextScan, err := CalculateNextScan(settings.CronSchedule)
	if err != nil {
		nextScan = "Error calculating next scan"
	}
	return lastScan, nextScan
}

func UpdateLastScanTime(db *gorm.DB) {
	currentTime := time.Now().Format("Jan 02 2006 3:04 PM")
	db.Exec("UPDATE settings SET last_scan = ?", currentTime)
}

func formatNextScan(nextScan time.Time) string {
	now := time.Now()
	if nextScan.Year() == now.Year() && nextScan.YearDay() == now.YearDay() {
		return "Today at " + nextScan.Format("3:04 PM")
	}
	if nextScan.Year() == now.Year() && nextScan.YearDay() == now.YearDay()+1 {
		return "Tomorrow at " + nextScan.Format("3:04 PM")
	}
	return nextScan.Format("Jan 02 at 3:04 PM")
}

func formatLastScan(lastScanStr string) string {
	const layout = "Jan 02 2006 3:04 PM"
	if lastScanStr == "" || lastScanStr == "No scan performed yet" {
		return "No scan performed yet"
	}
	lastScan, err := time.ParseInLocation(layout, lastScanStr, time.Local)
	if err != nil {
		return lastScanStr
	}
	now := time.Now()
	if lastScan.Year() == now.Year() && lastScan.YearDay() == now.YearDay() {
		return "Today at " + lastScan.Format("3:04 PM")
	}
	if lastScan.Year() == now.Year() && lastScan.YearDay() == now.YearDay()-1 {
		return "Yesterday at " + lastScan.Format("3:04 PM")
	}
	return lastScan.Format("Jan 02 at 3:04 PM")
}

### ./internal/services/monitor.go ###

package services

import (
	"encoding/json"
	"fmt"
	"net/http"
	"strings"
	"time"

	"surveillance/internal/models"
	"surveillance/internal/utils"

	"gorm.io/gorm"
)

type GitHubRelease struct {
	TagName     string `json:"tag_name"`
	PublishedAt string `json:"published_at"`
	Body        string `json:"body"`
}

func GetLatestReleaseInfo(repoName, githubToken string) (string, string, string) {
	client := &http.Client{
		Timeout: 10 * time.Second,
	}

	req, err := http.NewRequest("GET", "https://api.github.com/repos/"+repoName+"/releases/latest", nil)
	if err != nil {
		utils.Logger.Warnf("Failed to create request for %s: %v", repoName, err)
		return "", "", ""
	}
	if githubToken != "" {
		req.Header.Set("Authorization", "Bearer "+githubToken)
	}

	resp, err := client.Do(req)
	if err != nil {
		utils.Logger.Warnf("Failed to fetch release info for %s: %v", repoName, err)
		return "", "", ""
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		utils.Logger.Warnf("GitHub API request for %s failed with status: %s", repoName, resp.Status)
		return "", "", ""
	}

	var release GitHubRelease
	if err := json.NewDecoder(resp.Body).Decode(&release); err != nil {
		utils.Logger.Warnf("Failed to decode response for %s: %v", repoName, err)
		return "", "", ""
	}

	date, _ := time.Parse(time.RFC3339, release.PublishedAt)
	return release.TagName, date.Format("Jan 02 2006"), release.Body
}

func MonitorRepositories(db *gorm.DB, githubToken, scanType string, isManual bool) error {
	var repos []models.Repository
	if err := db.Find(&repos).Error; err != nil {
		utils.Logger.Error("‚ùå Failed to retrieve repositories: ", err)
		return err
	}
	emoji := "üîµ"
	if !isManual {
		emoji = "üü¢"
	}
	utils.Logger.Infof("%s %s scan started for %d repositories", emoji, scanType, len(repos))

	var updates strings.Builder
	var notifications []string

	for i := range repos {
		latestVersion, lastUpdated, changelog := GetLatestReleaseInfo(repos[i].Name, githubToken)
		if latestVersion == "" {
			continue
		}

		previousLatestRelease := repos[i].LatestRelease

		if repos[i].LatestRelease != latestVersion {
			if repos[i].NotifiedVersion != latestVersion {
				updates.WriteString(fmt.Sprintf("- [%s](%s): %s ‚Üí %s\n", repos[i].Name, repos[i].URL, previousLatestRelease, latestVersion))
				notifications = append(notifications, fmt.Sprintf("- [%s](%s): %s ‚Üí %s", repos[i].Name, repos[i].URL, previousLatestRelease, latestVersion))
				repos[i].NotifiedVersion = latestVersion
			}

			repos[i].LatestRelease = latestVersion
			repos[i].LastUpdated = lastUpdated
			repos[i].Changelog = changelog

			if err := db.Save(&repos[i]).Error; err != nil {
				utils.Logger.Error("‚ùå Failed to update repository: ", err)
				return err
			}
		}
	}

	if updates.Len() > 0 {
		formattedMsg := formatUpdates(notifications)
		utils.Logger.Infof("üîÑ Updated repositories:\n%s", formattedMsg)
		if err := SendDiscordNotification(db, formattedMsg, scanType); err != nil {
			utils.Logger.Errorf("Failed to send Discord notification: %v", err)
		}
	} else {
		utils.Logger.Info("‚úÖ All repositories are up to date.")
	}

	UpdateLastScanTime(db)
	utils.Logger.Infof("%s %s scan completed successfully", emoji, scanType)
	return nil
}

func formatUpdates(updates []string) string {
	return stringJoin(updates, "\n")
}

func stringJoin(items []string, sep string) string {
	result := ""
	for i, item := range items {
		result += item
		if i < len(items)-1 {
			result += sep
		}
	}
	return result
}

### ./internal/routes/auth/auth.go ###

package auth

import (
	"net/http"
	"os"
	"strings"
	"time"
	"unicode"

	"surveillance/internal/models"

	"github.com/golang-jwt/jwt/v4"
	"github.com/labstack/echo/v4"
	"golang.org/x/crypto/bcrypt"
	"gorm.io/gorm"
)

func RegisterPasswordPolicyRoute(e *echo.Echo) {
	e.GET("/api/password-policy", func(c echo.Context) error {
		return c.JSON(http.StatusOK, map[string]string{
			"pattern":     "^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[\\W_]).{12,}$",
			"description": "Password must be at least 12 characters long and include at least one uppercase letter, one lowercase letter, one number, and one special character.",
		})
	})
}

func generateJWT(user models.User) (string, error) {
	claims := jwt.MapClaims{
		"user_id": user.ID,
		"exp":     time.Now().Add(72 * time.Hour).Unix(),
	}
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
	jwtSecret := os.Getenv("JWT_SECRET")
	return token.SignedString([]byte(jwtSecret))
}

func sendErrorResponse(c echo.Context, status int, message string) error {
	return c.JSON(status, map[string]string{"error": message})
}

func checkPasswordStrength(password string) bool {
	if len(password) < 12 {
		return false
	}
	var hasLower, hasUpper, hasDigit, hasSpecial bool
	for _, r := range password {
		switch {
		case unicode.IsLower(r):
			hasLower = true
		case unicode.IsUpper(r):
			hasUpper = true
		case unicode.IsDigit(r):
			hasDigit = true
		case unicode.IsPunct(r) || unicode.IsSymbol(r):
			hasSpecial = true
		}
	}
	return hasLower && hasUpper && hasDigit && hasSpecial
}

func RegisterAuthRoutes(e *echo.Echo, db *gorm.DB) {
	e.POST("/auth/register", func(c echo.Context) error {
		var input struct {
			Username string `json:"username"`
			Password string `json:"password"`
		}
		if err := c.Bind(&input); err != nil {
			return sendErrorResponse(c, http.StatusBadRequest, "Invalid request payload")

		}
		if strings.TrimSpace(input.Username) == "" || strings.TrimSpace(input.Password) == "" {
			return sendErrorResponse(c, http.StatusBadRequest, "Username and password cannot be empty.")

		}
		if !checkPasswordStrength(input.Password) {
			return sendErrorResponse(c, http.StatusBadRequest, "Password does not meet the strength requirements.")

		}
		var count int64
		db.Model(&models.User{}).Where("username = ?", input.Username).Count(&count)
		if count > 0 {
			return sendErrorResponse(c, http.StatusConflict, "User already exists.")

		}
		hashedPassword, _ := bcrypt.GenerateFromPassword([]byte(input.Password), bcrypt.DefaultCost)
		user := models.User{Username: input.Username, Password: string(hashedPassword)}
		db.Create(&user)
		return c.JSON(http.StatusCreated, map[string]string{"message": "User registered successfully"})

	})

	e.POST("/auth/login", func(c echo.Context) error {
		var input struct {
			Username string `json:"username"`
			Password string `json:"password"`
		}
		if err := c.Bind(&input); err != nil {
			return sendErrorResponse(c, http.StatusBadRequest, "Invalid request payload")
		}
		input.Username = strings.TrimSpace(input.Username)
		input.Password = strings.TrimSpace(input.Password)
		if input.Username == "" || input.Password == "" {
			return sendErrorResponse(c, http.StatusBadRequest, "Username and password are required.")
		}
		var user models.User
		if err := db.Where("username = ?", input.Username).First(&user).Error; err != nil {
			return sendErrorResponse(c, http.StatusUnauthorized, "Invalid username or password.")
		}
		if err := bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(input.Password)); err != nil {
			return sendErrorResponse(c, http.StatusUnauthorized, "Invalid username or password.")
		}
		token, err := generateJWT(user)
		if err != nil {
			return sendErrorResponse(c, http.StatusInternalServerError, "Internal server error.")
		}
		return c.JSON(http.StatusOK, map[string]string{"token": token, "message": "Login successful."})
	})

	e.GET("/auth/exists", func(c echo.Context) error {
		var count int64
		db.Model(&models.User{}).Count(&count)
		return c.JSON(http.StatusOK, map[string]bool{"exists": count > 0})
	})
}

### ./internal/routes/notifications/notifications.go ###

package notifications

import (
	"net/http"
	"surveillance/internal/models"
	"surveillance/internal/services"

	"github.com/labstack/echo/v4"
	"gorm.io/gorm"
)

func RegisterNotificationRoutes(r *echo.Group, db *gorm.DB) {
	r.GET("/notifications", func(c echo.Context) error {
		var settings models.NotificationSettings
		if err := db.First(&settings).Error; err != nil {
			return c.JSON(http.StatusInternalServerError, map[string]string{"error": "Failed to retrieve settings"})
		}
		return c.JSON(http.StatusOK, settings)
	})

	r.POST("/notifications", func(c echo.Context) error {
		var input models.NotificationSettings
		if err := c.Bind(&input); err != nil {
			return c.JSON(http.StatusBadRequest, map[string]string{"error": "Invalid request"})
		}

		var settings models.NotificationSettings
		if err := db.First(&settings).Error; err != nil {
			settings = models.NotificationSettings{
				WebhookURL:    input.WebhookURL,
				DiscordName:   input.DiscordName,
				DiscordAvatar: input.DiscordAvatar,
				PingType:      input.PingType,
			}
			if err := db.Create(&settings).Error; err != nil {
				return c.JSON(http.StatusInternalServerError, map[string]string{"error": "Failed to create settings"})
			}
		} else {
			settings.WebhookURL = input.WebhookURL
			settings.DiscordName = input.DiscordName
			settings.DiscordAvatar = input.DiscordAvatar
			settings.PingType = input.PingType

			if err := db.Save(&settings).Error; err != nil {
				return c.JSON(http.StatusInternalServerError, map[string]string{"error": "Failed to update settings"})
			}
		}
		return c.JSON(http.StatusOK, map[string]string{"message": "Notification settings updated"})
	})

	r.POST("/notifications/test", func(c echo.Context) error {
		var settings models.NotificationSettings
		if err := db.First(&settings).Error; err != nil {
			return c.JSON(http.StatusInternalServerError, map[string]string{"error": "Failed to retrieve settings"})
		}
		if settings.WebhookURL == "" {
			return c.JSON(http.StatusBadRequest, map[string]string{"error": "Webhook URL is not set"})
		}

		if err := services.SendTestDiscordNotification(db); err != nil {
			return c.JSON(http.StatusInternalServerError, map[string]string{"error": "Test notification failed"})
		}

		return c.JSON(http.StatusOK, map[string]string{"message": "Test notification sent"})
	})
}

### ./internal/routes/repository/repository.go ###

package repository

import (
	"net/http"
	"surveillance/internal/models"
	"surveillance/internal/services"
	"surveillance/internal/utils"

	"github.com/labstack/echo/v4"
	"gorm.io/gorm"
)

func RegisterRepositoryRoutes(e *echo.Group, db *gorm.DB) {
	e.POST("/repositories", func(c echo.Context) error {
		var payload struct {
			Name    string `json:"name"`
			URL     string `json:"url"`
			Version string `json:"version"`
		}
		if err := c.Bind(&payload); err != nil {
			return c.JSON(http.StatusBadRequest, map[string]string{"error": "Invalid request"})
		}
		githubToken := utils.GetGitHubToken(db)
		utils.Logger.Infof("üü£ Initial scan started for %s", payload.Name)
		releaseVersion, releaseDate, changelog := services.GetLatestReleaseInfo(payload.Name, githubToken)
		if releaseVersion == "" {
			utils.Logger.Warnf("Failed to fetch GitHub release info for: %s", payload.Name)
			return c.JSON(http.StatusInternalServerError, map[string]string{"error": "Failed to retrieve latest release"})
		}
		repo := models.Repository{
			Name:            payload.Name,
			URL:             payload.URL,
			CurrentVersion:  ifEmpty(payload.Version, releaseVersion),
			LatestRelease:   releaseVersion,
			LastUpdated:     releaseDate,
			Changelog:       changelog,
			NotifiedVersion: releaseVersion,
		}
		if err := db.Create(&repo).Error; err != nil {
			utils.Logger.Error("Error adding repository: ", err)
			return c.JSON(http.StatusInternalServerError, map[string]string{"error": "Failed to add repository"})
		}

		utils.Logger.Infof("Latest release for %s: %s - %s", payload.Name, releaseVersion, releaseDate)
		utils.Logger.Infof("üü£ Initial scan finished")
		return c.JSON(http.StatusCreated, repo)
	})

	e.POST("/repositories/:id/mark-updated", func(c echo.Context) error {
		id := c.Param("id")
		var repo models.Repository
		if err := db.First(&repo, id).Error; err != nil {
			utils.Logger.Error("Repository not found: ", err)
			return c.JSON(http.StatusNotFound, map[string]string{"error": "Repository not found"})
		}

		repo.CurrentVersion = repo.LatestRelease
		repo.NotifiedVersion = repo.LatestRelease

		if err := db.Save(&repo).Error; err != nil {
			utils.Logger.Error("Failed to mark repository as updated: ", err)
			return c.JSON(http.StatusInternalServerError, map[string]string{"error": "Failed to mark repository as updated"})
		}
		if err := db.First(&repo, id).Error; err != nil {
			return c.JSON(http.StatusInternalServerError, map[string]string{"error": "Failed to retrieve updated repository"})
		}

		return c.JSON(http.StatusOK, repo)
	})

	e.GET("/repositories", func(c echo.Context) error {
		var repos []models.Repository
		if err := db.Find(&repos).Error; err != nil {
			utils.Logger.Error("Error fetching repositories: ", err)
			return c.JSON(http.StatusInternalServerError, map[string]string{"error": "Failed to fetch repositories"})
		}
		return c.JSON(http.StatusOK, repos)
	})

	e.GET("/repositories/:id/changelog", func(c echo.Context) error {
		repoID := c.Param("id")
		var repo models.Repository
		if err := db.First(&repo, repoID).Error; err != nil {
			utils.Logger.Error("Repository not found: ", err)
			return c.JSON(http.StatusNotFound, map[string]string{"error": "Repository not found"})
		}
		return c.JSON(http.StatusOK, map[string]string{"content": repo.Changelog})
	})

	e.PATCH("/repositories/:id", func(c echo.Context) error {
		repoID := c.Param("id")
		var repo models.Repository
		if err := db.First(&repo, repoID).Error; err != nil {
			utils.Logger.Error("Repository not found: ", err)
			return c.JSON(http.StatusNotFound, map[string]string{"error": "Repository not found"})
		}
		var payload struct {
			CurrentVersion string `json:"currentVersion"`
		}
		if err := c.Bind(&payload); err != nil {
			return c.JSON(http.StatusBadRequest, map[string]string{"error": "Invalid request payload"})
		}

		if payload.CurrentVersion == "" || payload.CurrentVersion == "latest" {
			repo.CurrentVersion = repo.LatestRelease
		} else {
			repo.CurrentVersion = payload.CurrentVersion
		}
		if err := db.Save(&repo).Error; err != nil {
			utils.Logger.Error("Error updating repository: ", err)
			return c.JSON(http.StatusInternalServerError, map[string]string{"error": "Failed to update repository"})
		}
		if err := db.First(&repo, repoID).Error; err != nil {
			return c.JSON(http.StatusInternalServerError, map[string]string{"error": "Failed to retrieve updated repository"})
		}
		return c.JSON(http.StatusOK, repo)
	})

	e.DELETE("/repositories/:id", func(c echo.Context) error {
		repoID := c.Param("id")
		var repo models.Repository
		if err := db.First(&repo, repoID).Error; err != nil {
			utils.Logger.Error("Repository not found: ", err)
			return c.JSON(http.StatusNotFound, map[string]string{"error": "Repository not found"})
		}
		if err := db.Delete(&repo).Error; err != nil {
			utils.Logger.Error("Error deleting repository: ", err)
			return c.JSON(http.StatusInternalServerError, map[string]string{"error": "Failed to delete repository"})
		}
		utils.Logger.Infof("üóëÔ∏è Repository %s deleted", repo.Name)
		return c.JSON(http.StatusOK, map[string]string{"message": "Repository deleted"})
	})
}

func ifEmpty(value, fallback string) string {
	if value == "" || value == "latest" {
		return fallback
	}
	return value
}

### ./internal/routes/validation/validation.go ###

package validation

import (
	"net/http"
	"surveillance/internal/utils"

	"github.com/labstack/echo/v4"
)

func RegisterValidationRoutes(e *echo.Echo) {
	e.POST("/api/validate-key", func(c echo.Context) error {
		var input struct {
			ApiKey string `json:"apiKey"`
		}
		if err := c.Bind(&input); err != nil {
			utils.Logger.Error("Invalid payload for API key validation.")
			return c.JSON(http.StatusBadRequest, map[string]string{"error": "Invalid request"})
		}
		if input.ApiKey == "" {
			return c.JSON(http.StatusOK, map[string]string{"message": "GitHub API key is valid"})
		}
		if err := utils.ValidateGitHubAPIKey(input.ApiKey); err != nil {
			utils.Logger.Error(err)
			return c.JSON(http.StatusUnauthorized, map[string]string{"error": err.Error()})
		}
		return c.JSON(http.StatusOK, map[string]string{"message": "GitHub API key is valid"})
	})
}

### ./internal/routes/routes.go ###

package routes

import (
	"log"
	"net/http"
	"os"
	"surveillance/internal/routes/auth"
	"surveillance/internal/routes/notifications"
	"surveillance/internal/routes/repository"
	"surveillance/internal/routes/scan"
	"surveillance/internal/routes/settings"
	"surveillance/internal/routes/validation"
	"surveillance/internal/utils"

	echojwt "github.com/labstack/echo-jwt/v4"
	"github.com/labstack/echo/v4"
	"github.com/robfig/cron/v3"
	"gorm.io/gorm"
)

func RegisterRoutes(e *echo.Echo, db *gorm.DB, scheduler *cron.Cron, jobID *cron.EntryID) {
	auth.RegisterAuthRoutes(e, db)
	auth.RegisterPasswordPolicyRoute(e)
	validation.RegisterValidationRoutes(e)

	jwtSecret := os.Getenv("JWT_SECRET")
	if jwtSecret == "" {
		log.Fatal("JWT_SECRET is not set in environment variables")
	}

	protected := e.Group("/api")
	protected.Use(echojwt.WithConfig(echojwt.Config{
		SigningKey: []byte(jwtSecret),
		Skipper: func(c echo.Context) bool {
			if c.Path() == "/api/settings" && c.Request().Method == http.MethodGet {
				return true
			}
			return false
		},
		ErrorHandler: func(c echo.Context, err error) error {
			utils.Logger.Errorf("JWT Error: %v", err)
			return c.JSON(http.StatusUnauthorized, map[string]string{"error": "Unauthorized - JWT validation failed."})
		},
	}))

	repository.RegisterRepositoryRoutes(protected, db)
	settings.RegisterSettingsRoutes(protected, db, scheduler, jobID)
	notifications.RegisterNotificationRoutes(protected, db)
	scan.RegisterScanRoutes(protected, db)
	protected.GET("/validate-key", func(c echo.Context) error {
		return c.JSON(http.StatusOK, map[string]string{"message": "GitHub API key is valid"})
	})

	e.GET("/*", func(c echo.Context) error {
		return c.File("./frontend/index.html")
	})
}

### ./internal/routes/settings/settings.go ###

package settings

import (
	"net/http"
	"surveillance/internal/models"
	"surveillance/internal/services"
	"surveillance/internal/utils"

	"github.com/labstack/echo/v4"
	"github.com/robfig/cron/v3"
	"gorm.io/gorm"
)

func RegisterSettingsRoutes(e *echo.Group, db *gorm.DB, scheduler *cron.Cron, jobID *cron.EntryID) {
	e.GET("/settings", func(c echo.Context) error {
		var settings models.Settings
		if err := db.First(&settings).Error; err != nil {
			utils.Logger.Error("Failed to retrieve settings: ", err)
			return c.JSON(http.StatusInternalServerError, map[string]string{"error": "Failed to retrieve settings"})
		}
		decryptedAPIKey := ""
		if settings.GitHubAPIKey != "" {
			var err error
			decryptedAPIKey, err = utils.DecryptAES(settings.GitHubAPIKey)
			if err != nil {
				utils.Logger.Warn("Decryption failed: ", err)
			}
		}
		return c.JSON(http.StatusOK, map[string]string{
			"githubApiKey": decryptedAPIKey,
			"cronSchedule": settings.CronSchedule,
			"theme":        settings.Theme,
		})
	})
	e.POST("/settings", func(c echo.Context) error {
		var input struct {
			Theme        string `json:"theme"`
			CronSchedule string `json:"cronSchedule"`
			GitHubAPIKey string `json:"githubApiKey"`
			IsReset      bool   `json:"isReset"`
		}
		if err := c.Bind(&input); err != nil {
			return c.JSON(http.StatusBadRequest, map[string]string{"error": "Invalid request"})
		}
		if input.CronSchedule == "" {
			return c.JSON(http.StatusBadRequest, map[string]string{"error": "Cron schedule cannot be empty"})
		}
		var settings models.Settings
		if err := db.First(&settings).Error; err != nil {
			return c.JSON(http.StatusInternalServerError, map[string]string{"error": "Failed to retrieve settings"})
		}
		settingsUpdated := false
		if settings.CronSchedule != input.CronSchedule {
			scheduler.Remove(*jobID)
			newJobID, err := scheduler.AddFunc(input.CronSchedule, func() {
				githubToken := utils.GetGitHubToken(db)
				if err := services.MonitorRepositories(db, githubToken, "", false); err != nil {
					utils.Logger.Errorf("Repository scan failed: %v", err)
				}
			})
			if err != nil {
				return c.JSON(http.StatusInternalServerError, map[string]string{"error": "Failed to schedule the new cron job"})
			}
			*jobID = newJobID
			settings.CronSchedule = input.CronSchedule
			settingsUpdated = true
			utils.Logger.Infof("Cron job updated with new schedule: %s", input.CronSchedule)
		}
		if input.IsReset {
			settings.GitHubAPIKey = ""
			settingsUpdated = true
			utils.Logger.Warn("GitHub API key has been reset.")
		} else if input.GitHubAPIKey != "" && input.GitHubAPIKey != "‚óè‚óè‚óè‚óè‚óè‚óè‚óè‚óè" {
			if err := utils.ValidateGitHubAPIKey(input.GitHubAPIKey); err == nil {
				encryptedKey, err := utils.EncryptAES(input.GitHubAPIKey)
				if err == nil {
					settings.GitHubAPIKey = encryptedKey
					settingsUpdated = true
					utils.Logger.Info("New GitHub API key validated and saved.")
				} else {
					utils.Logger.Error("Encryption failed: ", err)
				}
			} else {
				utils.Logger.Warn("Provided GitHub API key is invalid, skipping API key update.")
			}
		}
		if settings.Theme != input.Theme {
			settings.Theme = input.Theme
			settingsUpdated = true
		}
		if settingsUpdated {
			if err := db.Save(&settings).Error; err != nil {
				return c.JSON(http.StatusInternalServerError, map[string]string{"error": "Failed to update settings"})
			}
		}
		return c.JSON(http.StatusOK, map[string]string{"message": "Settings updated successfully"})
	})
}

### ./internal/routes/scan/scan.go ###

package scan

import (
	"net/http"
	"surveillance/internal/services"
	"surveillance/internal/utils"

	"github.com/labstack/echo/v4"
	"gorm.io/gorm"
)

func RegisterScanRoutes(r *echo.Group, db *gorm.DB) {
	r.POST("/scan-updates", func(c echo.Context) error {
		githubToken := utils.GetGitHubToken(db)
		if err := services.MonitorRepositories(db, githubToken, "Manual", true); err != nil {
			return c.JSON(http.StatusInternalServerError, map[string]string{"error": "Scan failed"})
		}
		services.UpdateLastScanTime(db)
		return c.JSON(http.StatusOK, map[string]string{"message": "Scan completed"})
	})
	r.GET("/scan-status", func(c echo.Context) error {
		lastScan, nextScan := services.GetLastAndNextScanTimes(db)
		return c.JSON(http.StatusOK, map[string]string{
			"lastScan": lastScan,
			"nextScan": nextScan,
		})
	})
}

### ./internal/models/settings.go ###

package models

import "gorm.io/gorm"

type Settings struct {
	gorm.Model
	GitHubAPIKey string
	CronSchedule string
	Theme        string
	LastScan     string
}

### ./internal/models/repository.go ###

package models

type Repository struct {
	ID              uint   `gorm:"primaryKey"`
	Name            string `gorm:"not null"`
	URL             string `gorm:"unique;not null"`
	CurrentVersion  string
	LatestRelease   string
	LastUpdated     string
	Changelog       string
	PublishedAt     string
	LastScan        string
	NotifiedVersion string
}

### ./internal/models/user.go ###

package models

import "gorm.io/gorm"

type User struct {
	gorm.Model
	Username string `gorm:"unique;not null"`
	Password string `gorm:"not null"`
}

### ./internal/models/notifications.go ###

package models

import "gorm.io/gorm"

type NotificationSettings struct {
	gorm.Model
	WebhookURL    string `json:"webhookUrl"`
	DiscordName   string `json:"discordName"`
	DiscordAvatar string `json:"discordAvatar"`
	PingType      string `json:"pingType"`
}

### ./internal/utils/logger.go ###

package utils

import (
	"crypto/rand"
	"encoding/base64"
	"os"

	"github.com/sirupsen/logrus"
)

var Logger = logrus.New()

func InitLogger() {
	Logger.SetOutput(os.Stdout)
	Logger.SetFormatter(&logrus.TextFormatter{
		FullTimestamp:   true,
		ForceColors:     true,
		TimestampFormat: "01/02/2006 15:04:05 PM",
	})
	Logger.SetLevel(logrus.InfoLevel)
}

func GenerateRandomString(length int) string {
	b := make([]byte, length)
	if _, err := rand.Read(b); err != nil {
		return ""
	}
	return base64.URLEncoding.EncodeToString(b)
}

### ./internal/utils/token.go ###

package utils

import (
	"fmt"
	"net/http"
	"surveillance/internal/models"

	"gorm.io/gorm"
)

func GetGitHubToken(db *gorm.DB) string {
	var settings models.Settings
	if err := db.First(&settings).Error; err == nil {
		if settings.GitHubAPIKey == "" {
			return ""
		}
		token, err := DecryptAES(settings.GitHubAPIKey)
		if err == nil {
			return token
		}
		Logger.Warn("Failed to decrypt GitHub token: ", err)
	}
	return ""
}

func ValidateGitHubAPIKey(apiKey string) error {
	if apiKey == "" {
		return nil
	}
	req, _ := http.NewRequest("GET", "https://api.github.com/user", nil)
	req.Header.Set("Authorization", fmt.Sprintf("Bearer %s", apiKey))
	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return fmt.Errorf("GitHub API request failed")
	}
	defer resp.Body.Close()
	if resp.StatusCode != http.StatusOK {
		return fmt.Errorf("GitHub API key validation failed")
	}
	return nil
}

### ./internal/utils/encryption.go ###

package utils

import (
	"crypto/aes"
	"crypto/cipher"
	"crypto/rand"
	"crypto/sha256"
	"encoding/base64"
	"errors"
	"io"

	"golang.org/x/crypto/pbkdf2"
)

var derivedKey []byte
var saltValue string

func SetEncryptionParameters(secret, salt string) {
	derivedKey = pbkdf2.Key([]byte(secret), []byte(salt), 10000, 32, sha256.New)
	saltValue = salt
}

func GetSalt() string {
	return saltValue
}

func GenerateRandomSalt(length int) (string, error) {
	salt := make([]byte, length)
	if _, err := rand.Read(salt); err != nil {
		return "", err
	}
	return base64.StdEncoding.EncodeToString(salt), nil
}

func EncryptAES(plainText string) (string, error) {
	if derivedKey == nil {
		return "", errors.New("encryption key not set")
	}
	block, err := aes.NewCipher(derivedKey)
	if err != nil {
		return "", err
	}
	aesGCM, err := cipher.NewGCM(block)
	if err != nil {
		return "", err
	}
	nonce := make([]byte, 12)
	if _, err := io.ReadFull(rand.Reader, nonce); err != nil {
		return "", err
	}
	cipherText := aesGCM.Seal(nil, nonce, []byte(plainText), nil)
	finalOutput := append(nonce, cipherText...)
	return base64.StdEncoding.EncodeToString(finalOutput), nil
}

func DecryptAES(cipherText string) (string, error) {
	if derivedKey == nil {
		return "", errors.New("encryption key not set")
	}
	block, err := aes.NewCipher(derivedKey)
	if err != nil {
		return "", err
	}
	aesGCM, err := cipher.NewGCM(block)
	if err != nil {
		return "", err
	}
	decoded, err := base64.StdEncoding.DecodeString(cipherText)
	if err != nil {
		return "", errors.New("invalid base64 ciphertext")
	}
	if len(decoded) < 12+aesGCM.Overhead() {
		return "", errors.New("invalid ciphertext length")
	}
	nonce, data := decoded[:12], decoded[12:]
	plainText, err := aesGCM.Open(nil, nonce, data, nil)
	if err != nil {
		return "", errors.New("decryption failed or authentication check failed")
	}
	return string(plainText), nil
}

### ./dev/populate_db.go ###

package main

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"log"
	"math/rand"
	"net/http"
	"strings"
	"time"

	"github.com/golang-jwt/jwt/v4"
)

// JWT secret (use a secure method to load it in production)
var jwtSecret = []byte("mysecretkey")

func main() {
	// Generate a token with 7 days expiration
	jwtToken, err := generateJWT(7 * 24 * time.Hour)
	if err != nil {
		log.Fatalf("Failed to generate JWT token: %v\n", err)
	}

	repoURLs := []string{
		"https://github.com/vercel/next.js",
		"https://github.com/facebook/react",
		"https://github.com/vuejs/vue",
		"https://github.com/angular/angular",
		"https://github.com/laravel/framework",
		"https://github.com/golang/go",
		"https://github.com/torvalds/linux",
		"https://github.com/microsoft/TypeScript",
		"https://github.com/django/django",
		"https://github.com/elastic/elasticsearch",
	}

	apiEndpoint := "http://localhost:8080/repositories"

	rand.Seed(time.Now().UnixNano())
	randomIndexes := generateRandomIndexes(len(repoURLs), 3) // Pick 3 random indexes

	for i, url := range repoURLs {
		name := extractRepoName(url)
		if name == "" {
			log.Printf("Skipping invalid URL: %s\n", url)
			continue
		}

		version := ""
		if contains(randomIndexes, i) {
			version = generateRandomVersion()
		}

		log.Printf("Sending POST request for repository: %s (version: %s)\n", name, version)

		jsonPayload := []byte(fmt.Sprintf(`{
			"name": "%s",
			"url": "%s",
			"version": "%s"
		}`, name, url, version))

		req, err := http.NewRequest("POST", apiEndpoint, bytes.NewBuffer(jsonPayload))
		if err != nil {
			log.Printf("Failed to create request for %s: %v\n", name, err)
			continue
		}

		req.Header.Set("Content-Type", "application/json")
		req.Header.Set("Authorization", "Bearer "+jwtToken)

		client := &http.Client{}
		resp, err := client.Do(req)
		if err != nil {
			log.Printf("Failed to send POST request for %s: %v\n", name, err)
			continue
		}

		body, _ := ioutil.ReadAll(resp.Body)
		defer resp.Body.Close()

		if resp.StatusCode == http.StatusCreated || resp.StatusCode == http.StatusOK {
			log.Printf("Successfully added: %s\n", name)
		} else {
			log.Printf("Failed to add %s - Status: %d - Response: %s\n", name, resp.StatusCode, body)
		}
	}

	log.Println("Repository seeding completed.")
}

// generateJWT generates a new JWT token with the given expiration duration
func generateJWT(expiration time.Duration) (string, error) {
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{
		"sub": "1234567890",                      // Subject (like user ID)
		"iat": time.Now().Unix(),                 // Issued at time
		"exp": time.Now().Add(expiration).Unix(), // Expiration time
	})

	tokenString, err := token.SignedString(jwtSecret)
	if err != nil {
		return "", fmt.Errorf("error generating token: %w", err)
	}
	return tokenString, nil
}

// extractRepoName parses the URL and returns "owner/repo"
func extractRepoName(url string) string {
	parts := strings.Split(strings.TrimSuffix(url, "/"), "/")
	if len(parts) >= 2 {
		return fmt.Sprintf("%s/%s", parts[len(parts)-2], parts[len(parts)-1])
	}
	return ""
}

// generateRandomVersion generates a random version string like "x.y.z"
func generateRandomVersion() string {
	major := rand.Intn(10) + 1 // Major version between 1 and 10
	minor := rand.Intn(10)     // Minor version between 0 and 9
	patch := rand.Intn(10)     // Patch version between 0 and 9
	return fmt.Sprintf("%d.%d.%d", major, minor, patch)
}

// generateRandomIndexes selects n unique random indexes from the range [0, max-1]
func generateRandomIndexes(max int, n int) []int {
	if n > max {
		n = max
	}

	indexes := make(map[int]struct{})
	for len(indexes) < n {
		indexes[rand.Intn(max)] = struct{}{}
	}

	result := make([]int, 0, len(indexes))
	for index := range indexes {
		result = append(result, index)
	}
	return result
}

// contains checks if a slice contains a specific element
func contains(slice []int, elem int) bool {
	for _, v := range slice {
		if v == elem {
			return true
		}
	}
	return false
}

### ./all_files_content.txt ###


### ./go.sum ###

github.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=
github.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/golang-jwt/jwt/v4 v4.5.1 h1:JdqV9zKUdtaa9gdPlywC3aeoEsR681PlKC+4F5gQgeo=
github.com/golang-jwt/jwt/v4 v4.5.1/go.mod h1:m21LjoU+eqJr34lmDMbreY2eSTRJ1cv77w39/MY0Ch0=
github.com/golang-jwt/jwt/v5 v5.2.1 h1:OuVbFODueb089Lh128TAcimifWaLhJwVflnrgM17wHk=
github.com/golang-jwt/jwt/v5 v5.2.1/go.mod h1:pqrtFR0X4osieyHYxtmOUWsAWrfe1Q5UVIyoH402zdk=
github.com/jinzhu/inflection v1.0.0 h1:K317FqzuhWc8YvSVlFMCCUb36O/S9MCKRDI7QkRKD/E=
github.com/jinzhu/inflection v1.0.0/go.mod h1:h+uFLlag+Qp1Va5pdKtLDYj+kHp5pxUVkryuEj+Srlc=
github.com/jinzhu/now v1.1.5 h1:/o9tlHleP7gOFmsnYNz3RGnqzefHA47wQpKrrdTIwXQ=
github.com/jinzhu/now v1.1.5/go.mod h1:d3SSVoowX0Lcu0IBviAWJpolVfI5UJVZZ7cO71lE/z8=
github.com/joho/godotenv v1.5.1 h1:7eLL/+HRGLY0ldzfGMeQkb7vMd0as4CfYvUVzLqw0N0=
github.com/joho/godotenv v1.5.1/go.mod h1:f4LDr5Voq0i2e/R5DDNOoa2zzDfwtkZa6DnEwAbqwq4=
github.com/labstack/echo-jwt/v4 v4.3.0 h1:8JcvVCrK9dRkPx/aWY3ZempZLO336Bebh4oAtBcxAv4=
github.com/labstack/echo-jwt/v4 v4.3.0/go.mod h1:OlWm3wqfnq3Ma8DLmmH7GiEAz2S7Bj23im2iPMEAR+Q=
github.com/labstack/echo/v4 v4.13.3 h1:pwhpCPrTl5qry5HRdM5FwdXnhXSLSY+WE+YQSeCaafY=
github.com/labstack/echo/v4 v4.13.3/go.mod h1:o90YNEeQWjDozo584l7AwhJMHN0bOC4tAfg+Xox9q5g=
github.com/labstack/gommon v0.4.2 h1:F8qTUNXgG1+6WQmqoUWnz8WiEU60mXVVw0P4ht1WRA0=
github.com/labstack/gommon v0.4.2/go.mod h1:QlUFxVM+SNXhDL/Z7YhocGIBYOiwB0mXm1+1bAPHPyU=
github.com/mattn/go-colorable v0.1.13 h1:fFA4WZxdEF4tXPZVKMLwD8oUnCTTo08duU7wxecdEvA=
github.com/mattn/go-colorable v0.1.13/go.mod h1:7S9/ev0klgBDR4GtXTXX8a3vIGJpMovkB8vQcUbaXHg=
github.com/mattn/go-isatty v0.0.16/go.mod h1:kYGgaQfpe5nmfYZH+SKPsOc2e4SrIfOl2e/yFXSvRLM=
github.com/mattn/go-isatty v0.0.20 h1:xfD0iDuEKnDkl03q4limB+vH+GxLEtL/jb4xVJSWWEY=
github.com/mattn/go-isatty v0.0.20/go.mod h1:W+V8PltTTMOvKvAeJH7IuucS94S2C6jfK/D7dTCTo3Y=
github.com/mattn/go-sqlite3 v1.14.22 h1:2gZY6PC6kBnID23Tichd1K+Z0oS6nE/XwU+Vz/5o4kU=
github.com/mattn/go-sqlite3 v1.14.22/go.mod h1:Uh1q+B4BYcTPb+yiD3kU8Ct7aC0hY9fxUwlHK0RXw+Y=
github.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=
github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=
github.com/robfig/cron/v3 v3.0.1 h1:WdRxkvbJztn8LMz/QEvLN5sBU+xKpSqwwUO1Pjr4qDs=
github.com/robfig/cron/v3 v3.0.1/go.mod h1:eQICP3HwyT7UooqI/z+Ov+PtYAWygg1TEWWzGIFLtro=
github.com/sirupsen/logrus v1.9.3 h1:dueUQJ1C2q9oE3F7wvmSGAaVtTmUizReu6fjN8uqzbQ=
github.com/sirupsen/logrus v1.9.3/go.mod h1:naHLuLoDiP4jHNo9R0sCBMtWGeIprob74mVsIT4qYEQ=
github.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=
github.com/stretchr/testify v1.7.0/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=
github.com/stretchr/testify v1.10.0 h1:Xv5erBjTwe/5IxqUQTdXv5kgmIvbHo3QQyRwhJsOfJA=
github.com/stretchr/testify v1.10.0/go.mod h1:r2ic/lqez/lEtzL7wO/rwa5dbSLXVDPFyf8C91i36aY=
github.com/valyala/bytebufferpool v1.0.0 h1:GqA5TC/0021Y/b9FG4Oi9Mr3q7XYx6KllzawFIhcdPw=
github.com/valyala/bytebufferpool v1.0.0/go.mod h1:6bBcMArwyJ5K/AmCkWv1jt77kVWyCJ6HpOuEn7z0Csc=
github.com/valyala/fasttemplate v1.2.2 h1:lxLXG0uE3Qnshl9QyaK6XJxMXlQZELvChBOCmQD0Loo=
github.com/valyala/fasttemplate v1.2.2/go.mod h1:KHLXt3tVN2HBp8eijSv/kGJopbvo7S+qRAEEKiv+SiQ=
golang.org/x/crypto v0.31.0 h1:ihbySMvVjLAeSH1IbfcRTkD/iNscyz8rGzjF/E5hV6U=
golang.org/x/crypto v0.31.0/go.mod h1:kDsLvtWBEx7MV9tJOj9bnXsPbxwJQ6csT/x4KIN4Ssk=
golang.org/x/net v0.33.0 h1:74SYHlV8BIgHIFC/LrYkOGIwL19eTYXQ5wc6TBuO36I=
golang.org/x/net v0.33.0/go.mod h1:HXLR5J+9DxmrqMwG9qjGCxZ+zKXxBru04zlTvWlWuN4=
golang.org/x/sys v0.0.0-20220715151400-c0bba94af5f8/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20220811171246-fbc7d0a398ab/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.6.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.29.0 h1:TPYlXGxvx1MGTn2GiZDhnjPA9wZzZeGKHHmKhHYvgaU=
golang.org/x/sys v0.29.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=
golang.org/x/text v0.21.0 h1:zyQAAkrwaneQ066sspRyJaG9VNi/YJ1NfzcGB3hZ/qo=
golang.org/x/text v0.21.0/go.mod h1:4IBbMaMmOPCJ8SecivzSH54+73PCFmPWxNTLm+vZkEQ=
golang.org/x/time v0.8.0 h1:9i3RxcPv3PZnitoVGMPDKZSq1xW1gK1Xy3ArNOGZfEg=
golang.org/x/time v0.8.0/go.mod h1:3BpzKBy/shNhVucY/MWOyx10tF3SFh9QdLuxbVysPQM=
gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
gopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=
gopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=
gopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=
gorm.io/driver/sqlite v1.5.7 h1:8NvsrhP0ifM7LX9G4zPB97NwovUakUxc+2V2uuf3Z1I=
gorm.io/driver/sqlite v1.5.7/go.mod h1:U+J8craQU6Fzkcvu8oLeAQmi50TkwPEhHDEjQZXDah4=
gorm.io/gorm v1.25.12 h1:I0u8i2hWQItBq1WfE0o2+WuL9+8L21K9e2HHSTE/0f8=
gorm.io/gorm v1.25.12/go.mod h1:xh7N7RHfYlNc5EmcI/El95gXusucDrQnHXe0+CgWcLQ=
